(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{199:function(t,a,r){"use strict";r.r(a);var e=r(0),i=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("div",{staticClass:"content"},[r("h2",{attrs:{id:"虚拟dom"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom","aria-hidden":"true"}},[t._v("#")]),t._v(" 虚拟DOM")]),t._v(" "),r("h3",{attrs:{id:"主要用处"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#主要用处","aria-hidden":"true"}},[t._v("#")]),t._v(" 主要用处")]),t._v(" "),r("p",[t._v("虚拟DOM主要用于映射真实DOM上，用于减少重复的大量的DOM渲染。将原来频繁的dom操作合并起来。")]),t._v(" "),r("h3",{attrs:{id:"原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#原理","aria-hidden":"true"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),r("p",[t._v("通过javascript对象表示出一个虚拟DOM用来映射真实DOM，视图的结构确实是整个全新渲染了，但是最后操作DOM的时候确实只变更有不同的地方。")]),t._v(" "),r("h3",{attrs:{id:"virtual-dom-算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#virtual-dom-算法","aria-hidden":"true"}},[t._v("#")]),t._v(" Virtual DOM 算法")]),t._v(" "),r("p",[t._v("1 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中\n2 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异（diff算法，diff也是虚拟dom的核心）\n3 把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了")]),t._v(" "),r("p",[t._v("Virtual DOM与DocumentFragment\nVirtualDOM的目的是不仅允许对稍后注入DOM的系统进行大规模编辑，而且允许在不存在DOM的环境中进行任何编辑。这是DocumentFragments和VirtualDOM的实际应用之间的最大区别。")])])}],!1,null,null,null);a.default=i.exports}}]);